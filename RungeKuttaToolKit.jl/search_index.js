var documenterSearchIndex = {"docs":
[{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/#Elementary-Differentials-and-Butcher-Series","page":"Background","title":"Elementary Differentials and Butcher Series","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"If you've studied calculus, you know that any analytic function f R to R can be written as a Taylor series. For all x in R and sufficiently small h in R, we have:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"f(x + h) = f(x) + hf(x) + frach^22f(x) + frach^36f(x) + cdots + frach^nnf^(n)(x) + cdots","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In the study of differential equations, we use a special form of Taylor series called a Butcher series, named after the mathematician John C. Butcher. Unlike a Taylor series, whose terms are indexed by a natural number n in N, the terms of a Butcher series are indexed by rooted trees.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"To understand the structure of a Butcher series, let's say we're trying to analyze a system of differential equations.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"beginaligned\ny_1(t) = f_1(y_1(t) y_2(t) ldots y_n(t)) \ny_2(t) = f_2(y_1(t) y_2(t) ldots y_n(t)) \nhspace2mm vdots \ny_n(t) = f_n(y_1(t) y_2(t) ldots y_n(t))\nendaligned","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Here, y_1 y_2 ldots y_n R to R are the unknown functions we're trying to find, and f_1 f_2 dots f_n R^n to R are the known right-hand side functions. To simplify our notation, we can rewrite this system in vector form:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"vy(t) = vf(vy(t))","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Here, we have gathered the unknown functions y_1 y_2 ldots y_n and right-hand side functions f_1 f_2 dots f_n into vector-valued functions vy R to R^n and vf R^n to R^n.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"beginaligned\nvy = vf \nvy = vfvf \nvy = vfvf vf + vfvfvf \nvy = vfvf vf vf + vfvfvf vf + vfvf vfvf + \nhspace5mm vfvfvf vf + vfvfvf vf + vfvfvfvf\nendaligned","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Definition: Let t be a rooted tree. The extension of t, denoted by t, is the rooted tree obtained from t by adjoining a new vertex v, adding a new edge from v to the root of t, and designating v as the root of t.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Definition: Let s and t be rooted trees. The rooted sum of s and t, denoted by s hash t, is the rooted tree obtained by taking the disjoint union of s and t and merging their roots into a single vertex, which is designated as the root of s hash t.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"<p><strong>Example:</strong> Suppose <span>$s =$</span>\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"41\" height=\"91\" viewBox=\"-20.5 -83 41 91\" style=\"vertical-align: middle;\">\n<line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"-25\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"-25\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"0\" y1=\"-25\" x2=\"0\" y2=\"-50\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"-25\" x2=\"0\" y2=\"-50\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"0\" y1=\"-50\" x2=\"-12.5\" y2=\"-75\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"-50\" x2=\"-12.5\" y2=\"-75\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"0\" y1=\"-50\" x2=\"12.5\" y2=\"-75\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"-50\" x2=\"12.5\" y2=\"-75\" stroke=\"black\" stroke-width=\"3.0\" />\n<circle cx=\"0\" cy=\"0\" r=\"7\" stroke=\"white\" />\n<circle cx=\"0\" cy=\"-25\" r=\"7\" stroke=\"white\" />\n<circle cx=\"0\" cy=\"-50\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-12.5\" cy=\"-75\" r=\"7\" stroke=\"white\" />\n<circle cx=\"12.5\" cy=\"-75\" r=\"7\" stroke=\"white\" />\n</svg>\nand <span>$t =$</span>\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"41\" height=\"66\" viewBox=\"-20.5 -58 41 66\" style=\"vertical-align: middle;\">\n<line x1=\"0\" y1=\"0\" x2=\"-12.5\" y2=\"-25\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"-12.5\" y2=\"-25\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"-12.5\" y1=\"-25\" x2=\"-12.5\" y2=\"-50\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"-12.5\" y1=\"-25\" x2=\"-12.5\" y2=\"-50\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"12.5\" y2=\"-25\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"12.5\" y2=\"-25\" stroke=\"black\" stroke-width=\"3.0\" />\n<circle cx=\"0\" cy=\"0\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-12.5\" cy=\"-25\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-12.5\" cy=\"-50\" r=\"7\" stroke=\"white\" />\n<circle cx=\"12.5\" cy=\"-25\" r=\"7\" stroke=\"white\" />\n</svg>.\nThen <span>$[t] =$</span>\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"41\" height=\"91\" viewBox=\"-20.5 -83 41 91\" style=\"vertical-align: middle;\">\n<line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"-25\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"-25\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"0\" y1=\"-25\" x2=\"-12.5\" y2=\"-50\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"-25\" x2=\"-12.5\" y2=\"-50\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"-12.5\" y1=\"-50\" x2=\"-12.5\" y2=\"-75\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"-12.5\" y1=\"-50\" x2=\"-12.5\" y2=\"-75\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"0\" y1=\"-25\" x2=\"12.5\" y2=\"-50\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"-25\" x2=\"12.5\" y2=\"-50\" stroke=\"black\" stroke-width=\"3.0\" />\n<circle cx=\"0\" cy=\"0\" r=\"7\" stroke=\"white\" />\n<circle cx=\"0\" cy=\"-25\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-12.5\" cy=\"-50\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-12.5\" cy=\"-75\" r=\"7\" stroke=\"white\" />\n<circle cx=\"12.5\" cy=\"-50\" r=\"7\" stroke=\"white\" />\n</svg>\nand <span>$s \\hash t =$</span>\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"91\" height=\"91\" viewBox=\"-45.5 -83 91 91\" style=\"vertical-align: middle;\">\n<line x1=\"0\" y1=\"0\" x2=\"-25\" y2=\"-25\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"-25\" y2=\"-25\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"-25\" y1=\"-25\" x2=\"-25\" y2=\"-50\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"-25\" y1=\"-25\" x2=\"-25\" y2=\"-50\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"-25\" y1=\"-50\" x2=\"-37.5\" y2=\"-75\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"-25\" y1=\"-50\" x2=\"-37.5\" y2=\"-75\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"-25\" y1=\"-50\" x2=\"-12.5\" y2=\"-75\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"-25\" y1=\"-50\" x2=\"-12.5\" y2=\"-75\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"12.5\" y2=\"-25\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"12.5\" y2=\"-25\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"12.5\" y1=\"-25\" x2=\"12.5\" y2=\"-50\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"12.5\" y1=\"-25\" x2=\"12.5\" y2=\"-50\" stroke=\"black\" stroke-width=\"3.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"37.5\" y2=\"-25\" stroke=\"white\" stroke-width=\"5.0\" />\n<line x1=\"0\" y1=\"0\" x2=\"37.5\" y2=\"-25\" stroke=\"black\" stroke-width=\"3.0\" />\n<circle cx=\"0\" cy=\"0\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-25\" cy=\"-25\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-25\" cy=\"-50\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-37.5\" cy=\"-75\" r=\"7\" stroke=\"white\" />\n<circle cx=\"-12.5\" cy=\"-75\" r=\"7\" stroke=\"white\" />\n<circle cx=\"12.5\" cy=\"-25\" r=\"7\" stroke=\"white\" />\n<circle cx=\"12.5\" cy=\"-50\" r=\"7\" stroke=\"white\" />\n<circle cx=\"37.5\" cy=\"-25\" r=\"7\" stroke=\"white\" />\n</svg>.\n</p>","category":"page"},{"location":"#RungeKuttaToolKit.jl","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RungeKuttaToolKit.jl is a Julia package for designing and analyzing Runge–Kutta methods for solving ordinary differential equations. The main tool it provides is the RKOCEvaluator type, which implements fast algorithms for evaluating the residuals and gradients of the Runge–Kutta order conditions","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"mathbfb cdot Phi_t(A) = frac1gamma(t)","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"over a given set of rooted trees t in T.","category":"page"},{"location":"#Features","page":"RungeKuttaToolKit.jl","title":"Features","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RungeKuttaToolKit.jl is designed for extremely high performance and stable memory usage. It evaluates Runge–Kutta order conditions and their derivatives millions of times per second on a single CPU core, using fast in-place algorithms that allocate zero memory outside of RKOCEvaluator construction.\nRungeKuttaToolKit.jl works with all numeric types that support arithmetic (+ - * /), including low-precision and high-precision floating-point types, BigFloat, Rational, and even symbolic types.\nRungeKuttaToolKit.jl is lightweight and has only two dependencies outside of Julia Base: SIMD.jl and MultiFloats.jl.\nRungeKuttaToolKit.jl is regularly and extensively tested for correctness and performance.","category":"page"},{"location":"#Quick-Start","page":"RungeKuttaToolKit.jl","title":"Quick Start","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"To install RungeKuttaToolKit.jl, run ]add RungeKuttaToolKit in the Julia REPL.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"using RungeKuttaToolKit\n\norder = 4\nnum_stages = 4\n\n# RK4 Butcher tableau\nA = [0.0 0.0 0.0 0.0;\n     0.5 0.0 0.0 0.0;\n     0.0 0.5 0.0 0.0;\n     0.0 0.0 1.0 0.0]\nb = [1/6, 1/3, 1/3, 1/6]\n\nev = RKOCEvaluator(order, num_stages)\nresiduals = ev(A, b)\nprintln(residuals) # This should be close to zero,\n# which confirms that RK4 is a fourth-order method.\n\n# An RKOCEvaluator can also be constructed from a set of\n# rooted trees. Here, we select only the trees of order 5.\ntrees = rooted_trees(order + 1)\nsigma = inv.(Float64.(butcher_symmetry.(trees)))\nerr_ev = RKOCEvaluator(trees, num_stages)\nerror_coeffs = sigma .* err_ev(A, b)\nprintln(error_coeffs) # This computes the principal error\n# coefficients of RK4, which should all be nonzero.","category":"page"},{"location":"#Generating-Rooted-Trees","page":"RungeKuttaToolKit.jl","title":"Generating Rooted Trees","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"The first step in using RungeKuttaToolKit.jl is generating a list of rooted trees. Each Runge–Kutta order condition mathbfb cdot Phi_t(A) = 1gamma(t) corresponds to a rooted tree t. For a Runge–Kutta method (A mathbfb) to have order p, it needs to satisfy this equation for all rooted trees t having up to p vertices.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RungeKuttaToolKit.jl provides two functions for generating rooted trees: rooted_trees(n), which generates all rooted trees with exactly n vertices, and all_rooted_trees(n), which generates all rooted trees with at most n vertices.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"rooted_trees","category":"page"},{"location":"#RungeKuttaToolKit.ButcherInstructions.rooted_trees","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.ButcherInstructions.rooted_trees","text":"rooted_trees(\n    n::Integer;\n    tree_ordering::Symbol=:reverse_lexicographic,\n) -> Vector{LevelSequence}\n\nCompute and return a list of all rooted trees with exactly n vertices. Several algorithms that generate rooted trees in different orderings are available:\n\n:reverse_lexicographic (default) is the asymptotically optimal algorithm   devised by Terry Beyer and Sandra Mitchell Hedetniemi that generates rooted   trees in constant time per tree. It generates rooted trees in reverse   lexicographic order of their canonical level sequence representation.   This is the fastest known algorithm, but unlike the others, it produces   the tall tree first and the bushy tree last.\n:lexicographic generates rooted trees in lexicographic order of their   canonical level sequence representation. It simply runs the   :reverse_lexicographic algorithm and reverses its output.   This algorithm produces the bushy tree first and the tall tree last.\n:attach generates rooted trees of order n by attaching a leaf to each   vertex of each rooted tree of order n-1, starting from the root and   proceeding depth-first. This is the ordering produced by paper-and-pencil   application of the product rule to the set of elementary differentials.   This is the slowest algorithm, but it is arguably the most intuitive.   It produces the bushy tree first and the tall tree last.\n:butcher is Algorithm 3   from John Butcher's monograph on B-Series,   which generates rooted trees in a canonical ordering often used in the   literature on Runge–Kutta methods. It produces the bushy tree first and   the tall tree last.\n\n\n\n\n\n","category":"function"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"all_rooted_trees","category":"page"},{"location":"#RungeKuttaToolKit.ButcherInstructions.all_rooted_trees","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.ButcherInstructions.all_rooted_trees","text":"all_rooted_trees(\n    n::Integer;\n    tree_ordering::Symbol=:reverse_lexicographic,\n) -> Vector{LevelSequence}\n\nCompute and return a list of all rooted trees with up to n vertices. Several algorithms that generate rooted trees in different orderings are available:\n\n:reverse_lexicographic (default) is the asymptotically optimal algorithm   devised by Terry Beyer and Sandra Mitchell Hedetniemi that generates rooted   trees in constant time per tree. It generates rooted trees in reverse   lexicographic order of their canonical level sequence representation.   This is the fastest known algorithm, but unlike the others, it produces   the tall tree first and the bushy tree last.\n:lexicographic generates rooted trees in lexicographic order of their   canonical level sequence representation. It simply runs the   :reverse_lexicographic algorithm and reverses its output.   This algorithm produces the bushy tree first and the tall tree last.\n:attach generates rooted trees of order n by attaching a leaf to each   vertex of each rooted tree of order n-1, starting from the root and   proceeding depth-first. This is the ordering produced by paper-and-pencil   application of the product rule to the set of elementary differentials.   This is the slowest algorithm, but it is arguably the most intuitive.   It produces the bushy tree first and the tall tree last.\n:butcher is Algorithm 3   from John Butcher's monograph on B-Series,   which generates rooted trees in a canonical ordering often used in the   literature on Runge–Kutta methods. It produces the bushy tree first and   the tall tree last.\n\n\n\n\n\n","category":"function"},{"location":"#RKOCEvaluator-Construction","page":"RungeKuttaToolKit.jl","title":"RKOCEvaluator Construction","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"With a list of rooted trees in hand, we can construct an RKOCEvaluator object, which is used to evaluate the residuals and gradients of the Runge–Kutta order conditions with respect to the entries of A and mathbfb. The RKOCEvaluator constructor analyzes the given list of rooted trees to identify common subtrees whose Butcher weight vectors Phi_t(A) can be reused to eliminate redundant computation.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKOCEvaluator","category":"page"},{"location":"#RungeKuttaToolKit.RKOCEvaluator","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKOCEvaluator","text":"RKOCEvaluator{T}(\n    trees::AbstractVector{LevelSequence},\n    num_stages::Integer,\n) -> RKOCEvaluator{T}\n\nConstruct an RKOCEvaluator that encodes a given list of rooted trees.\n\nArguments\n\ntrees: input list of rooted trees in LevelSequence representation.\nnum_stages: number of stages (i.e., size of the Butcher tableau). Must be   specified at construction time to allocate internal workspace arrays.\n\nIf the type T is not specified, it defaults to Float64.\n\n\n\n\n\nRKOCEvaluator{T}(order::Integer, num_stages::Integer) -> RKOCEvaluator{T}\n\nConstruct an RKOCEvaluator that encodes all rooted trees having at most order vertices. This is equivalent to RKOCEvaluator{T}(all_rooted_trees(order), num_stages).\n\nIf the type T is not specified, it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RungeKuttaToolKit.jl v3.3 and later also provides the RKOCEvaluatorSIMD type, which exposes an identical interface to RKOCEvaluator but internally uses SIMD.jl to accelerate execution on CPUs with vector instruction sets, such as Intel AVX and Arm SVE. On modern CPUs, such as the AMD Ryzen 9 9950X, RKOCEvaluatorSIMD can be up to 10x faster than RKOCEvaluator.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"Note that the RKOCEvaluatorSIMD constructor has a different signature, but after construction, usage is identical to RKOCEvaluator.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKOCEvaluatorSIMD","category":"page"},{"location":"#RungeKuttaToolKit.RKOCEvaluatorSIMD","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKOCEvaluatorSIMD","text":"RKOCEvaluatorSIMD{S,T}(\n    trees::AbstractVector{LevelSequence},\n) -> RKOCEvaluatorSIMD{S,T}\n\nConstruct an RKOCEvaluatorSIMD that encodes a given list of rooted trees.\n\nUnlike a standard RKOCEvaluator, the number of stages S is provided as a static type parameter in order to statically determine the SIMD vector width.\n\nArguments\n\ntrees: input list of rooted trees in LevelSequence representation.\n\nIf the type T is not specified, it defaults to Float64.\n\n\n\n\n\nRKOCEvaluatorSIMD{S,T}(order::Integer) -> RKOCEvaluatorSIMD{S,T}\n\nConstruct an RKOCEvaluatorSIMD that encodes all rooted trees having at most order vertices. This is equivalent to RKOCEvaluatorSIMD{S,T}(all_rooted_trees(order)).\n\nUnlike a standard RKOCEvaluator, the number of stages S is provided as a static type parameter in order to statically determine the SIMD vector width.\n\nIf the type T is not specified, it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"#RKOCEvaluator-Usage","page":"RungeKuttaToolKit.jl","title":"RKOCEvaluator Usage","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"An RKOCEvaluator object can be used to perform seven operations which are summarized below. A full description of each operation follows the summary.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"ev([residuals,] A, b): Compute residuals.\nev(cost, A, b): Compute cost function.\nev'([dresiduals,] A, dA, b, db): Compute directional derivatives.    of residuals\nev'([dresiduals,] A, i, j, b): Compute partial derivatives of residuals.    with respect to A_ij\nev'([dresiduals,] A, i): Compute partial derivatives of residuals.    with respect to b_i\nev'([dA, db,] cost, A, b): Compute gradient of cost function.\nev'([jacobian, A, b,] param, x): Compute Jacobian of residuals    with respect to parameterization.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"Every operation that returns a matrix or vector has an allocating version that returns its result in a new array and an in-place version that writes its result to an existing array. We use square brackets to denote optional output arguments. For example, the operation ev([residuals,] A, b) can be called as ev(A, b) (allocating) or ev(residuals, A, b) (in-place).","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"As a mnemonic device, the operations that compute derivatives are called with a single quote ' following the RKOCEvaluator object, emulating the prime symbol f(x) used to denote derivatives in mathematical notation. This distinguishes operations like ev(cost, A, b) and ev'(cost, A, b) that would otherwise have identical function signatures.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RungeKuttaToolKit.AbstractRKOCEvaluator","category":"page"},{"location":"#RungeKuttaToolKit.AbstractRKOCEvaluator","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.AbstractRKOCEvaluator","text":"(ev::AbstractRKOCEvaluator{T})(\n    [residuals::AbstractVector{T},]\n    A::AbstractMatrix{T},\n    b::AbstractVector{T},\n) -> AbstractVector{T}\n\nCompute residuals of the Runge–Kutta order conditions  mathbfb cdot Phi_t(A) - 1gamma(t)  t in T  for a given Butcher tableau (A mathbfb) over a list of rooted trees T encoded by an AbstractRKOCEvaluator.\n\nArguments\n\nev: AbstractRKOCEvaluator object encoding a list of rooted trees.\nresiduals: length T output vector. Each residual   mathbfb cdot Phi_t(A) - 1gamma(t) is written to   residuals[i] in the order specified when constructing ev.   If not provided, a new vector is allocated and returned.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\n\nHere, T denotes the number of rooted trees encoded by ev, and s denotes the number of stages specified when constructing ev.\n\n\n\n\n\n(ev::AbstractRKOCEvaluator{T})(\n    cost::AbstractRKCost{T},\n    A::AbstractMatrix{T},\n    b::AbstractVector{T},\n) -> T\n\nCompute a specified cost function f of the residuals of the Runge–Kutta order conditions f( mathbfb cdot Phi_t(A) - 1gamma(t)  t in T ) for a given Butcher tableau (A mathbfb) over a list of rooted trees T encoded by an AbstractRKOCEvaluator.\n\nArguments\n\nev: AbstractRKOCEvaluator object encoding a list of rooted trees.\ncost: AbstractRKCost object specifying the cost function f.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\n\nHere, s denotes the number of stages specified when constructing ev.\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RungeKuttaToolKit.AbstractRKOCAdjoint","category":"page"},{"location":"#RungeKuttaToolKit.AbstractRKOCAdjoint","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.AbstractRKOCAdjoint","text":"(adj::AbstractRKOCAdjoint{T})(\n    [dresiduals::AbstractVector{T},]\n    A::AbstractMatrix{T},\n    dA::AbstractMatrix{T},\n    b::AbstractVector{T},\n    db::AbstractVector{T},\n) -> AbstractVector{T}\n\nCompute directional derivatives of the Runge–Kutta order conditions  nabla_mathrmdA mathrmdmathbfb  mathbfb cdot Phi_t(A)   t in T  at a given Butcher tableau (A mathbfb) in direction (mathrmdA mathrmdmathbfb) over a list of rooted trees T encoded by an AbstractRKOCEvaluator.\n\nArguments\n\nadj: AbstractRKOCAdjoint object obtained by applying the adjoint   operator ' to an AbstractRKOCEvaluator. In other words, this function   should be called as ev'([dresiduals,] A, dA, b, db) where ev is an   AbstractRKOCEvaluator.\ndresiduals: length T output vector. Each directional derivative   nabla_mathrmdA mathrmdmathbfb    mathbfb cdot Phi_t(A)  is written to dresiduals[i] in the   order specified when constructing ev. If not provided, a new vector is   allocated and returned.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\ndA: s times s input matrix containing the direction in which to   differentiate A.\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\ndb: length s input vector containing the direction in which to   differentiate mathbfb.\n\nHere, T denotes the number of rooted trees encoded by ev, and s denotes the number of stages specified when constructing ev.\n\n\n\n\n\n(adj::AbstractRKOCAdjoint{T})(\n    [dresiduals::AbstractVector{T},]\n    A::AbstractMatrix{T},\n    i::Integer,\n    j::Integer,\n    b::AbstractVector{T},\n) -> AbstractVector{T}\n\nCompute partial derivatives of the Runge–Kutta order conditions  partial_A_ij  mathbfb cdot Phi_t(A)   t in T  with respect to A_ij at a given Butcher tableau (A mathbfb) over a list of rooted trees T encoded by an AbstractRKOCEvaluator.\n\nArguments\n\nadj: AbstractRKOCAdjoint object obtained by applying the adjoint   operator ' to an AbstractRKOCEvaluator. In other words, this function   should be called as ev'([dresiduals,] A, dA, b, db) where ev is an   AbstractRKOCEvaluator.\ndresiduals: length T output vector. Each partial derivative   partial_A_ij  mathbfb cdot Phi_t(A)  is written to   dresiduals[i] in the order specified when constructing ev.   If not provided, a new vector is allocated and returned.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\ni: row index of the entry of A to differentiate with respect to.\nj: column index of the entry of A to differentiate with respect to.\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\n\nHere, T denotes the number of rooted trees encoded by ev, and s denotes the number of stages specified when constructing ev.\n\nThis method uses an optimized algorithm that should be faster than ev'(dresiduals, A, dA, b, db) when differentiating with respect to a single entry of A. It may produce slightly different results due to the non-associative nature of floating-point arithmetic.\n\n\n\n\n\n(adj::AbstractRKOCAdjoint{T})(\n    [dresiduals::AbstractVector{T},]\n    A::AbstractMatrix{T},\n    i::Integer,\n) -> AbstractVector{T}\n\nCompute partial derivatives of the Runge–Kutta order conditions  partial_b_i  mathbfb cdot Phi_t(A)   t in T  with respect to b_i at a given Butcher tableau A over a list of rooted trees T encoded by an AbstractRKOCEvaluator. (The result is independent of the value of mathbfb.)\n\nArguments\n\nadj: AbstractRKOCAdjoint object obtained by applying the adjoint   operator ' to an AbstractRKOCEvaluator. In other words, this function   should be called as ev'([dresiduals,] A, dA, b, db) where ev is an   AbstractRKOCEvaluator.\ndresiduals: length T output vector. Each partial derivative   partial_b_i  mathbfb cdot Phi_t(A)  is written to   dresiduals[i] in the order specified when constructing ev.   If not provided, a new vector is allocated and returned.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\ni: index of the entry of mathbfb to differentiate with respect to.\n\nHere, T denotes the number of rooted trees encoded by ev, and s denotes the number of stages specified when constructing ev.\n\nThis method uses an optimized algorithm that should be faster than ev'(dresiduals, A, dA, b, db) when differentiating with respect to a single entry of mathbfb. It may produce slightly different results due to the non-associative nature of floating-point arithmetic.\n\n\n\n\n\n(adj::AbstractRKOCAdjoint{T})(\n    [dA::AbstractMatrix{T},\n     db::AbstractVector{T},]\n    cost::AbstractRKCost{T},\n    A::AbstractMatrix{T},\n    b::AbstractVector{T},\n) -> Tuple{AbstractMatrix{T}, AbstractVector{T}}\n\nCompute the gradient of a specified cost function f of the residuals of the Runge–Kutta order conditions nabla_A mathbfb f( mathbfb cdot Phi_t(A) - 1gamma(t)  t in T ) at a given Butcher tableau (A mathbfb) over a list of rooted trees T encoded by an AbstractRKOCEvaluator.\n\nArguments\n\nadj: AbstractRKOCAdjoint object obtained by applying the adjoint   operator ' to an AbstractRKOCEvaluator. In other words, this function   should be called as ev'([dA, db,] cost, A, b) where ev is an   AbstractRKOCEvaluator.\ndA: s times s output matrix containing the gradient of f with   respect to A. If not provided, a new matrix is allocated and returned.\ndb: length s output vector containing the gradient of f with   respect to mathbfb. If not provided, a new vector is allocated   and returned.\ncost: AbstractRKCost object specifying the cost function f.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\n\nHere, s denotes the number of stages specified when constructing ev.\n\n\n\n\n\n(adj::AbstractRKOCAdjoint{T})(\n    [jacobian::AbstractMatrix{T},\n     A::AbstractMatrix{T},\n     b::AbstractVector{T},]\n    param::AbstractRKParameterization{T},\n    x::AbstractVector{T},\n) -> AbstractMatrix{T}\n\nCompute the Jacobian of the residuals of the Runge–Kutta order conditions nabla_mathbfx  mathbfb(mathbfx) cdot Phi_t(A(mathbfx)) - 1gamma(t)  t in T  with respect to a specified Butcher tableau parameterization mathbfx in mathbbR^n mapsto (A(mathbfx) mathbfb(mathbfx)) over a list of rooted trees T encoded by an AbstractRKOCEvaluator.\n\nArguments\n\nadj: AbstractRKOCAdjoint object obtained by applying the adjoint   operator ' to an AbstractRKOCEvaluator. In other words, this function   should be called as ev'([jacobian, A, b,] param, x) where ev is an   AbstractRKOCEvaluator.\njacobian: T times n output matrix. The partial derivative of the   ith residual with respect to the jth coordinate of mathbfx   is written to jacobian[i, j]. If not provided, a new matrix is allocated   and returned.\nA: s times s output matrix containing the output   A(mathbfx) of the Butcher tableau parameterization.   If not provided, a new temporary matrix is allocated.\nb: length s output vector containing the output   mathbfb(mathbfx) of the Butcher tableau parameterization.   If not provided, a new temporary vector is allocated.\nparam: AbstractRKParameterization object specifying a Butcher tableau   parameterization, i.e., a mapping from a vector of parameters   mathbfx in mathbbR^n to a Butcher tableau   (A(mathbfx) mathbfb(mathbfx)).\nx: length n input vector containing the parameters mathbfx.\n\nHere, T denotes the number of rooted trees encoded by ev, s denotes the number of stages specified when constructing ev, and n denotes the number of free parameters in param.\n\n\n\n\n\n","category":"type"},{"location":"#Cost-Functions","page":"RungeKuttaToolKit.jl","title":"Cost Functions","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKCostL1","category":"page"},{"location":"#RungeKuttaToolKit.RKCost.RKCostL1","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKCost.RKCostL1","text":"sum_t in T leftlvert\nmathbfb cdot Phi_t(A) - frac1gamma(t)\nrightrvert\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKCostWeightedL1","category":"page"},{"location":"#RungeKuttaToolKit.RKCost.RKCostWeightedL1","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKCost.RKCostWeightedL1","text":"sum_t in T w_t leftlvert\nmathbfb cdot Phi_t(A) - frac1gamma(t)\nrightrvert\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKCostL2","category":"page"},{"location":"#RungeKuttaToolKit.RKCost.RKCostL2","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKCost.RKCostL2","text":"sum_t in T left(\nmathbfb cdot Phi_t(A) - frac1gamma(t)\nright)^2\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKCostWeightedL2","category":"page"},{"location":"#RungeKuttaToolKit.RKCost.RKCostWeightedL2","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKCost.RKCostWeightedL2","text":"sum_t in T w_t left(\nmathbfb cdot Phi_t(A) - frac1gamma(t)\nright)^2\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKCostLInfinity","category":"page"},{"location":"#RungeKuttaToolKit.RKCost.RKCostLInfinity","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKCost.RKCostLInfinity","text":"max_t in T leftlvert\nmathbfb cdot Phi_t(A) - frac1gamma(t)\nrightrvert\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"Derivatives are not yet implemented for RKCostLInfinity.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKCostWeightedLInfinity","category":"page"},{"location":"#RungeKuttaToolKit.RKCost.RKCostWeightedLInfinity","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKCost.RKCostWeightedLInfinity","text":"max_t in T w_t leftlvert\nmathbfb cdot Phi_t(A) - frac1gamma(t)\nrightrvert\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"Derivatives are not yet implemented for RKCostWeightedLInfinity.","category":"page"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKCostHuber","category":"page"},{"location":"#RungeKuttaToolKit.RKCost.RKCostHuber","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKCost.RKCostHuber","text":"sum_t in T H_deltaleft(\nmathbfb cdot Phi_t(A) - frac1gamma(t)\nright)\n\nH_delta(x) = begincases\nx^2  textif  lvert x rvert leq delta \n2 delta lvert x rvert - delta^2  textotherwise\nendcases\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKCostWeightedHuber","category":"page"},{"location":"#RungeKuttaToolKit.RKCost.RKCostWeightedHuber","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKCost.RKCostWeightedHuber","text":"sum_t in T w_t H_deltaleft(\nmathbfb cdot Phi_t(A) - frac1gamma(t)\nright)\n\nH_delta(x) = begincases\nx^2  textif  lvert x rvert leq delta \n2 delta lvert x rvert - delta^2  textotherwise\nendcases\n\n\n\n\n\n","category":"type"},{"location":"#Parameterizations","page":"RungeKuttaToolKit.jl","title":"Parameterizations","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKParameterizationExplicit","category":"page"},{"location":"#RungeKuttaToolKit.RKParameterization.RKParameterizationExplicit","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKParameterization.RKParameterizationExplicit","text":"\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKParameterizationDiagonallyImplicit","category":"page"},{"location":"#RungeKuttaToolKit.RKParameterization.RKParameterizationDiagonallyImplicit","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKParameterization.RKParameterizationDiagonallyImplicit","text":"\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKParameterizationImplicit","category":"page"},{"location":"#RungeKuttaToolKit.RKParameterization.RKParameterizationImplicit","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKParameterization.RKParameterizationImplicit","text":"\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.jl","text":"RKParameterizationParallelExplicit","category":"page"},{"location":"#RungeKuttaToolKit.RKParameterization.RKParameterizationParallelExplicit","page":"RungeKuttaToolKit.jl","title":"RungeKuttaToolKit.RKParameterization.RKParameterizationParallelExplicit","text":"\n\n\n\n","category":"type"}]
}
