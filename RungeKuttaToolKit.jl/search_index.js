var documenterSearchIndex = {"docs":
[{"location":"#RungeKuttaToolKit.jl-Documentation","page":"RungeKuttaToolKit.jl Documentation","title":"RungeKuttaToolKit.jl Documentation","text":"","category":"section"},{"location":"","page":"RungeKuttaToolKit.jl Documentation","title":"RungeKuttaToolKit.jl Documentation","text":"RKOCEvaluator","category":"page"},{"location":"#RungeKuttaToolKit.RKOCEvaluator","page":"RungeKuttaToolKit.jl Documentation","title":"RungeKuttaToolKit.RKOCEvaluator","text":"RKOCEvaluator{T}(\n    trees::AbstractVector{LevelSequence},\n    num_stages::Int;\n    optimize::Bool=true,\n    sort_by_depth::Bool=true,\n) -> RKOCEvaluator{T}\n\nConstruct an RKOCEvaluator that encodes a given sequence of rooted trees.\n\nArguments\n\ntrees: input vector of rooted trees in LevelSequence representation.\nnum_stages: number of stages (i.e., size of the Butcher tableau). Must be   known at construction time to allocate internal workspace arrays.\noptimize: if true, perform common subtree elimination. This may improve   performance in cases where trees is not the complete set of all rooted   trees up to a certain order.\nsort_by_depth: if true, permute internal workspace arrays so that   intermediate results are calculated in an order that enables parallel   execution. This has no effect on single-threaded execution and is provided   for forward compatibility with future parallel implementations.\n\nNote that different permutations of trees, in addition to different values of optimize and sort_by_depth, may yield slightly different results due to the non-associative nature of floating-point arithmetic.\n\n\n\n\n\nRKOCEvaluator{T}(order::Int, num_stages::Int) -> RKOCEvaluator{T}\n\nConstruct an RKOCEvaluator that encodes all rooted trees having at most order vertices.\n\nBy default, rooted trees are generated in graded reverse lexicographic order of their level sequence representation. This specific ordering maximizes the efficiency of generating all rooted trees.\n\n\n\n\n\n(ev::RKOCEvaluator{T})(\n    residuals::AbstractVector{T},\n    A::AbstractMatrix{T},\n    b::AbstractVector{T}\n) -> AbstractVector{T}\n\nCompute residuals of the Runge–Kutta order conditions  mathbfb cdot Phi_t(A) - 1gamma(t)  t in T  for a given Butcher tableau (A mathbfb) over a set of rooted trees T encoded by an RKOCEvaluator.\n\nArguments\n\nev: RKOCEvaluator object encoding a set of rooted trees.\nresiduals: length T output vector. Each residual   mathbfb cdot Phi_t(A) - 1gamma(t) is written to   residuals[i] in the order specified when constructing ev.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\n\nHere, T denotes the number of rooted trees encoded by ev, and s denotes the number of stages specified when constructing ev.\n\n\n\n\n\n(ev::RKOCEvaluator{T})(\n    A::AbstractMatrix{T},\n    b::AbstractVector{T}\n) -> T\n\nCompute the sum of squared residuals of the Runge–Kutta order conditions sum_t in T (mathbfb cdot Phi_t(A) - 1gamma(t))^2 for a given Butcher tableau (A mathbfb) over a set of rooted trees T encoded by an RKOCEvaluator.\n\nArguments\n\nev: RKOCEvaluator object encoding a set of rooted trees.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\n\nHere, s denotes the number of stages specified when constructing ev.\n\n\n\n\n\n","category":"type"},{"location":"","page":"RungeKuttaToolKit.jl Documentation","title":"RungeKuttaToolKit.jl Documentation","text":"RungeKuttaToolKit.RKOCAdjoint","category":"page"},{"location":"#RungeKuttaToolKit.RKOCAdjoint","page":"RungeKuttaToolKit.jl Documentation","title":"RungeKuttaToolKit.RKOCAdjoint","text":"(adj::RKOCAdjoint{T})(\n    dresiduals::AbstractVector{T},\n    A::AbstractMatrix{T},\n    dA::AbstractMatrix{T},\n    b::AbstractVector{T},\n    db::AbstractVector{T},\n) -> AbstractVector{T}\n\nCompute directional derivatives of the Runge–Kutta order conditions  nabla_mathrmdA mathrmdmathbfb  mathbfb cdot Phi_t(A)   t in T  at a given Butcher tableau (A mathbfb) in direction (mathrmdA mathrmdmathbfb) over a set of rooted trees T encoded by an RKOCEvaluator.\n\nArguments\n\nadj: RKOCAdjoint object obtained by applying the adjoint operator '   to an RKOCEvaluator. In other words, this function should be called as   ev'(dresiduals, A, dA, b, db) where ev is an RKOCEvaluator.\ndresiduals: length T output vector. Each directional derivative   nabla_mathrmdA mathrmdmathbfb    mathbfb cdot Phi_t(A)  is written to dresiduals[i] in the   order specified when constructing ev.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\ndA: s times s input matrix containing the direction in which to   differentiate A.\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\ndb: length s input vector containing the direction in which to   differentiate mathbfb.\n\nHere, T denotes the number of rooted trees encoded by ev, and s denotes the number of stages specified when constructing ev.\n\n\n\n\n\n(adj::RKOCAdjoint{T})(\n    dresiduals::AbstractVector{T},\n    A::AbstractMatrix{T},\n    i::Int,\n    j::Int,\n    b::AbstractVector{T},\n) -> AbstractVector{T}\n\nCompute partial derivatives of the Runge–Kutta order conditions  partial_A_ij  mathbfb cdot Phi_t(A)   t in T  with respect to A_ij at a given Butcher tableau (A mathbfb) over a set of rooted trees T encoded by an RKOCEvaluator.\n\nArguments\n\nadj: RKOCAdjoint object obtained by applying the adjoint operator '   to an RKOCEvaluator. In other words, this function should be called as   ev'(dresiduals, A, i, j, b) where ev is an RKOCEvaluator.\ndresiduals: length T output vector. Each partial derivative   partial_A_ij  mathbfb cdot Phi_t(A)  is written to   dresiduals[i] in the order specified when constructing ev.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\ni: row index of the entry of A to differentiate with respect to.\nj: column index of the entry of A to differentiate with respect to.\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\n\nHere, T denotes the number of rooted trees encoded by ev, and s denotes the number of stages specified when constructing ev.\n\nThis method uses an optimized algorithm that should be faster than ev'(dresiduals, A, dA, b, db) when differentiating with respect to a single entry of A. It may produce slightly different results due to the non-associative nature of floating-point arithmetic.\n\n\n\n\n\n(adj::RKOCAdjoint{T})(\n    dresiduals::AbstractVector{T},\n    A::AbstractMatrix{T},\n    i::Int,\n) -> AbstractVector{T}\n\nCompute partial derivatives of the Runge–Kutta order conditions  partial_b_i  mathbfb cdot Phi_t(A)   t in T  with respect to b_i at a given Butcher tableau A over a set of rooted trees T encoded by an RKOCEvaluator. (The result is independent of the value of mathbfb.)\n\nArguments\n\nadj: RKOCAdjoint object obtained by applying the adjoint operator '   to an RKOCEvaluator. In other words, this function should be called as   ev'(dresiduals, A, i) where ev is an RKOCEvaluator.\ndresiduals: length T output vector. Each partial derivative   partial_b_i  mathbfb cdot Phi_t(A)  is written to   dresiduals[i] in the order specified when constructing ev.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\ni: index of the entry of mathbfb to differentiate with respect to.\n\nHere, T denotes the number of rooted trees encoded by ev, and s denotes the number of stages specified when constructing ev.\n\nThis method uses an optimized algorithm that should be faster than ev'(dresiduals, A, dA, b, db) when differentiating with respect to a single entry of mathbfb. It may produce slightly different results due to the non-associative nature of floating-point arithmetic.\n\n\n\n\n\n(adj::RKOCAdjoint{T})(\n    dA::AbstractMatrix{T},\n    db::AbstractVector{T},\n    A::AbstractMatrix{T},\n    b::AbstractVector{T},\n) -> Tuple{AbstractMatrix{T}, AbstractVector{T}}\n\nCompute the gradient of the sum of squared residuals of the Runge–Kutta order conditions nabla_A mathbfb sum_t in T (mathbfb cdot Phi_t(A) - 1gamma(t))^2 at a given Butcher tableau (A mathbfb) over a set of rooted trees T encoded by an RKOCEvaluator.\n\nArguments\n\nadj: RKOCAdjoint object obtained by applying the adjoint operator '   to an RKOCEvaluator. In other words, this function should be called as   ev'(dA, db, A, b) where ev is an RKOCEvaluator.\ndA: s times s output matrix containing the gradient of the sum of   squared residuals with respect to A.\ndb: length s output vector containing the gradient of the sum of   squared residuals with respect to mathbfb.\nA: s times s input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).\nb: length s input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).\n\nHere, s denotes the number of stages specified when constructing ev.\n\n\n\n\n\n","category":"type"}]
}
