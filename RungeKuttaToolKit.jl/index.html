<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>RungeKuttaToolKit.jl · Documentation</title><meta name="title" content="RungeKuttaToolKit.jl · Documentation"/><meta property="og:title" content="RungeKuttaToolKit.jl · Documentation"/><meta property="twitter:title" content="RungeKuttaToolKit.jl · Documentation"/><meta name="description" content="Documentation for Documentation."/><meta property="og:description" content="Documentation for Documentation."/><meta property="twitter:description" content="Documentation for Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>RungeKuttaToolKit.jl</a><ul class="internal"><li><a class="tocitem" href="#Features"><span>Features</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Generating-Rooted-Trees"><span>Generating Rooted Trees</span></a></li><li><a class="tocitem" href="#RKOCEvaluator-Construction"><span><code>RKOCEvaluator</code> Construction</span></a></li><li><a class="tocitem" href="#RKOCEvaluator-Usage"><span><code>RKOCEvaluator</code> Usage</span></a></li><li><a class="tocitem" href="#Cost-Functions"><span>Cost Functions</span></a></li><li><a class="tocitem" href="#Parameterizations"><span>Parameterizations</span></a></li></ul></li><li><a class="tocitem" href="background/">Background</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>RungeKuttaToolKit.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>RungeKuttaToolKit.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dzhang314/RungeKuttaToolKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="RungeKuttaToolKit.jl"><a class="docs-heading-anchor" href="#RungeKuttaToolKit.jl">RungeKuttaToolKit.jl</a><a id="RungeKuttaToolKit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RungeKuttaToolKit.jl" title="Permalink"></a></h1><p><strong>RungeKuttaToolKit.jl</strong> is a Julia package for designing and analyzing <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge–Kutta methods</a> for solving <a href="https://en.wikipedia.org/wiki/Ordinary_differential_equation">ordinary differential equations</a>. The main tool it provides is the <code>RKOCEvaluator</code> type, which implements fast algorithms for evaluating the residuals and gradients of the Runge–Kutta order conditions</p><p class="math-container">\[\mathbf{b} \cdot \Phi_t(A) = \frac{1}{\gamma(t)}\]</p><p>over a given set of rooted trees <span>$t \in T$</span>.</p><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><ul><li><strong>RungeKuttaToolKit.jl</strong> is designed for <strong>extremely high performance</strong> and <strong>stable memory usage</strong>. It evaluates Runge–Kutta order conditions and their derivatives millions of times per second on a single CPU core, using fast in-place algorithms that allocate zero memory outside of <code>RKOCEvaluator</code> construction.</li><li><strong>RungeKuttaToolKit.jl</strong> works with <strong>all numeric types</strong> that support arithmetic (<code>+</code> <code>-</code> <code>*</code> <code>/</code>), including low-precision and high-precision floating-point types, <code>BigFloat</code>, <code>Rational</code>, and even symbolic types.</li><li><strong>RungeKuttaToolKit.jl</strong> is lightweight and has <strong>zero dependencies</strong> outside of Julia <code>Base</code>.</li><li><strong>RungeKuttaToolKit.jl</strong> is <a href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/master/test/runtests.jl"><strong>regularly and extensively tested</strong></a> for correctness and performance.</li></ul><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><p>To install <strong>RungeKuttaToolKit.jl</strong>, run <code>]add RungeKuttaToolKit</code> in the Julia REPL.</p><pre><code class="language-julia hljs">using RungeKuttaToolKit

order = 4
num_stages = 4

# RK4 Butcher tableau
A = [0.0 0.0 0.0 0.0;
     0.5 0.0 0.0 0.0;
     0.0 0.5 0.0 0.0;
     0.0 0.0 1.0 0.0]
b = [1/6, 1/3, 1/3, 1/6]

ev = RKOCEvaluator(order, num_stages)
residuals = ev(A, b)
println(residuals) # This should be close to zero,
# which confirms that RK4 is a fourth-order method.

# An RKOCEvaluator can also be constructed from a set of
# rooted trees. Here, we select only the trees of order 5.
trees = rooted_trees(order + 1)
sigma = inv.(Float64.(butcher_symmetry.(trees)))
err_ev = RKOCEvaluator(trees, num_stages)
error_coeffs = sigma .* err_ev(A, b)
println(error_coeffs) # This computes the principal error
# coefficients of RK4, which should all be nonzero.</code></pre><h2 id="Generating-Rooted-Trees"><a class="docs-heading-anchor" href="#Generating-Rooted-Trees">Generating Rooted Trees</a><a id="Generating-Rooted-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Rooted-Trees" title="Permalink"></a></h2><p>The first step in using <strong>RungeKuttaToolKit.jl</strong> is generating a list of rooted trees. Each Runge–Kutta order condition <span>$\mathbf{b} \cdot \Phi_t(A) = 1/\gamma(t)$</span> corresponds to a rooted tree <span>$t$</span>. For a Runge–Kutta method <span>$(A, \mathbf{b})$</span> to have order <span>$p$</span>, it needs to satisfy this equation for all rooted trees <span>$t$</span> having up to <span>$p$</span> vertices.</p><p><strong>RungeKuttaToolKit.jl</strong> provides two functions for generating rooted trees: <code>rooted_trees(n)</code>, which generates all rooted trees with <strong>exactly</strong> <span>$n$</span> vertices, and <code>all_rooted_trees(n)</code>, which generates all rooted trees with <strong>at most</strong> <span>$n$</span> vertices.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.ButcherInstructions.rooted_trees" href="#RungeKuttaToolKit.ButcherInstructions.rooted_trees"><code>RungeKuttaToolKit.ButcherInstructions.rooted_trees</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rooted_trees(
    n::Integer;
    tree_ordering::Symbol=:reverse_lexicographic,
) -&gt; Vector{LevelSequence}</code></pre><p>Compute and return a list of all rooted trees with <strong>exactly</strong> <span>$n$</span> vertices. Several algorithms that generate rooted trees in different orderings are available:</p><ul><li><code>:reverse_lexicographic</code> (default) is the asymptotically optimal algorithm   <a href="https://epubs.siam.org/doi/pdf/10.1137/0209055">devised by Terry Beyer and Sandra Mitchell Hedetniemi</a> that generates rooted   trees in constant time per tree. It generates rooted trees in reverse   lexicographic order of their canonical level sequence representation.   This is the fastest known algorithm, but unlike the others, it produces   the tall tree first and the bushy tree last.</li><li><code>:lexicographic</code> generates rooted trees in lexicographic order of their   canonical level sequence representation. It simply runs the   <code>:reverse_lexicographic</code> algorithm and reverses its output.   This algorithm produces the bushy tree first and the tall tree last.</li><li><code>:attach</code> generates rooted trees of order <span>$n$</span> by attaching a leaf to each   vertex of each rooted tree of order <span>$n-1$</span>, starting from the root and   proceeding depth-first. This is the ordering produced by paper-and-pencil   application of the product rule to the set of elementary differentials.   This is the slowest algorithm, but it is arguably the most intuitive.   It produces the bushy tree first and the tall tree last.</li><li><code>:butcher</code> is <a href="https://link.springer.com/content/pdf/10.1007/978-3-030-70956-3_2">Algorithm 3</a>   from <a href="https://link.springer.com/content/pdf/10.1007/978-3-030-70956-3.pdf">John Butcher&#39;s monograph on B-Series</a>,   which generates rooted trees in a canonical ordering often used in the   literature on Runge–Kutta methods. It produces the bushy tree first and   the tall tree last.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/ButcherInstructions.jl#L492-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.ButcherInstructions.all_rooted_trees" href="#RungeKuttaToolKit.ButcherInstructions.all_rooted_trees"><code>RungeKuttaToolKit.ButcherInstructions.all_rooted_trees</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_rooted_trees(
    n::Integer;
    tree_ordering::Symbol=:reverse_lexicographic,
) -&gt; Vector{LevelSequence}</code></pre><p>Compute and return a list of all rooted trees with <strong>up to</strong> <span>$n$</span> vertices. Several algorithms that generate rooted trees in different orderings are available:</p><ul><li><code>:reverse_lexicographic</code> (default) is the asymptotically optimal algorithm   <a href="https://epubs.siam.org/doi/pdf/10.1137/0209055">devised by Terry Beyer and Sandra Mitchell Hedetniemi</a> that generates rooted   trees in constant time per tree. It generates rooted trees in reverse   lexicographic order of their canonical level sequence representation.   This is the fastest known algorithm, but unlike the others, it produces   the tall tree first and the bushy tree last.</li><li><code>:lexicographic</code> generates rooted trees in lexicographic order of their   canonical level sequence representation. It simply runs the   <code>:reverse_lexicographic</code> algorithm and reverses its output.   This algorithm produces the bushy tree first and the tall tree last.</li><li><code>:attach</code> generates rooted trees of order <span>$n$</span> by attaching a leaf to each   vertex of each rooted tree of order <span>$n-1$</span>, starting from the root and   proceeding depth-first. This is the ordering produced by paper-and-pencil   application of the product rule to the set of elementary differentials.   This is the slowest algorithm, but it is arguably the most intuitive.   It produces the bushy tree first and the tall tree last.</li><li><code>:butcher</code> is <a href="https://link.springer.com/content/pdf/10.1007/978-3-030-70956-3_2">Algorithm 3</a>   from <a href="https://link.springer.com/content/pdf/10.1007/978-3-030-70956-3.pdf">John Butcher&#39;s monograph on B-Series</a>,   which generates rooted trees in a canonical ordering often used in the   literature on Runge–Kutta methods. It produces the bushy tree first and   the tall tree last.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/ButcherInstructions.jl#L548-L582">source</a></section></article><h2 id="RKOCEvaluator-Construction"><a class="docs-heading-anchor" href="#RKOCEvaluator-Construction"><code>RKOCEvaluator</code> Construction</a><a id="RKOCEvaluator-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#RKOCEvaluator-Construction" title="Permalink"></a></h2><p>With a list of rooted trees in hand, we can construct an <code>RKOCEvaluator</code> object, which is used to evaluate the residuals and gradients of the Runge–Kutta order conditions with respect to the entries of <span>$A$</span> and <span>$\mathbf{b}$</span>. The <code>RKOCEvaluator</code> constructor analyzes the given list of rooted trees to identify common subtrees whose Butcher weight vectors <span>$\Phi_t(A)$</span> can be reused to eliminate redundant computation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKOCEvaluator" href="#RungeKuttaToolKit.RKOCEvaluator"><code>RungeKuttaToolKit.RKOCEvaluator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RKOCEvaluator{T}(
    trees::AbstractVector{LevelSequence},
    num_stages::Integer,
) -&gt; RKOCEvaluator{T}</code></pre><p>Construct an <code>RKOCEvaluator</code> that encodes a given list of rooted trees.</p><p><strong>Arguments</strong></p><ul><li><code>trees</code>: input list of rooted trees in <code>LevelSequence</code> representation.</li><li><code>num_stages</code>: number of stages (i.e., size of the Butcher tableau). Must be   specified at construction time to allocate internal workspace arrays.</li></ul><p>If the type <code>T</code> is not specified, it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RungeKuttaToolKit.jl#L67-L81">source</a></section><section><div><pre><code class="language-julia hljs">RKOCEvaluator{T}(order::Integer, num_stages::Integer) -&gt; RKOCEvaluator{T}</code></pre><p>Construct an <code>RKOCEvaluator</code> that encodes all rooted trees having at most <code>order</code> vertices. This is equivalent to <code>RKOCEvaluator{T}(all_rooted_trees(order), num_stages)</code>.</p><p>If the type <code>T</code> is not specified, it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RungeKuttaToolKit.jl#L98-L106">source</a></section></article><h2 id="RKOCEvaluator-Usage"><a class="docs-heading-anchor" href="#RKOCEvaluator-Usage"><code>RKOCEvaluator</code> Usage</a><a id="RKOCEvaluator-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#RKOCEvaluator-Usage" title="Permalink"></a></h2><p>An <code>RKOCEvaluator</code> object can be used to perform seven operations which are summarized below. A full description of each operation follows the summary.</p><ul><li><code>ev([residuals,] A, b)</code>: Compute residuals.</li><li><code>ev(cost, A, b)</code>: Compute cost function.</li><li><code>ev&#39;([dresiduals,] A, dA, b, db)</code>: Compute directional derivatives.    of residuals</li><li><code>ev&#39;([dresiduals,] A, i, j, b)</code>: Compute partial derivatives of residuals.    with respect to <span>$A_{i,j}$</span></li><li><code>ev&#39;([dresiduals,] A, i)</code>: Compute partial derivatives of residuals.    with respect to <span>$b_i$</span></li><li><code>ev&#39;([dA, db,] cost, A, b)</code>: Compute gradient of cost function.</li><li><code>ev&#39;([jacobian, A, b,] param, x)</code>: Compute Jacobian of residuals    with respect to parameterization.</li></ul><p>Every operation that returns a matrix or vector has an <strong>allocating version</strong> that returns its result in a new array and an <strong>in-place version</strong> that writes its result to an existing array. We use square brackets to denote optional output arguments. For example, the operation <code>ev([residuals,] A, b)</code> can be called as <code>ev(A, b)</code> (allocating) or <code>ev(residuals, A, b)</code> (in-place).</p><p>As a mnemonic device, the operations that compute derivatives are called with a single quote <code>&#39;</code> following the <code>RKOCEvaluator</code> object, emulating the prime symbol <span>$f&#39;(x)$</span> used to denote derivatives in mathematical notation. This distinguishes operations like <code>ev(cost, A, b)</code> and <code>ev&#39;(cost, A, b)</code> that would otherwise have identical function signatures.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.AbstractRKOCEvaluator" href="#RungeKuttaToolKit.AbstractRKOCEvaluator"><code>RungeKuttaToolKit.AbstractRKOCEvaluator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(ev::AbstractRKOCEvaluator{T})(
    [residuals::AbstractVector{T},]
    A::AbstractMatrix{T},
    b::AbstractVector{T},
) -&gt; AbstractVector{T}</code></pre><p>Compute residuals of the Runge–Kutta order conditions <span>$\{ \mathbf{b} \cdot \Phi_t(A) - 1/\gamma(t) : t \in T \}$</span> for a given Butcher tableau <span>$(A, \mathbf{b})$</span> over a list of rooted trees <span>$T$</span> encoded by an <code>AbstractRKOCEvaluator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ev</code>: <code>AbstractRKOCEvaluator</code> object encoding a list of rooted trees.</li><li><code>residuals</code>: length <span>$|T|$</span> output vector. Each residual   <span>$\mathbf{b} \cdot \Phi_t(A) - 1/\gamma(t)$</span> is written to   <code>residuals[i]</code> in the order specified when constructing <code>ev</code>.   If not provided, a new vector is allocated and returned.</li><li><code>A</code>: <span>$s \times s$</span> input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).</li><li><code>b</code>: length <span>$s$</span> input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).</li></ul><p>Here, <span>$|T|$</span> denotes the number of rooted trees encoded by <code>ev</code>, and <span>$s$</span> denotes the number of stages specified when constructing <code>ev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/AbstractRKInterface.jl#L10-L35">source</a></section><section><div><pre><code class="language-julia hljs">(ev::AbstractRKOCEvaluator{T})(
    cost::AbstractRKCost{T},
    A::AbstractMatrix{T},
    b::AbstractVector{T},
) -&gt; T</code></pre><p>Compute a specified cost function <span>$f$</span> of the residuals of the Runge–Kutta order conditions <span>$f(\{ \mathbf{b} \cdot \Phi_t(A) - 1/\gamma(t) : t \in T \})$</span> for a given Butcher tableau <span>$(A, \mathbf{b})$</span> over a list of rooted trees <span>$T$</span> encoded by an <code>AbstractRKOCEvaluator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ev</code>: <code>AbstractRKOCEvaluator</code> object encoding a list of rooted trees.</li><li><code>cost</code>: <code>AbstractRKCost</code> object specifying the cost function <span>$f$</span>.</li><li><code>A</code>: <span>$s \times s$</span> input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).</li><li><code>b</code>: length <span>$s$</span> input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).</li></ul><p>Here, <span>$s$</span> denotes the number of stages specified when constructing <code>ev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/AbstractRKInterface.jl#L67-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.AbstractRKOCAdjoint" href="#RungeKuttaToolKit.AbstractRKOCAdjoint"><code>RungeKuttaToolKit.AbstractRKOCAdjoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(adj::AbstractRKOCAdjoint{T})(
    [dresiduals::AbstractVector{T},]
    A::AbstractMatrix{T},
    dA::AbstractMatrix{T},
    b::AbstractVector{T},
    db::AbstractVector{T},
) -&gt; AbstractVector{T}</code></pre><p>Compute directional derivatives of the Runge–Kutta order conditions <span>$\{ \nabla_{\mathrm{d}A, \mathrm{d}\mathbf{b}} [ \mathbf{b} \cdot \Phi_t(A) ] : t \in T \}$</span> at a given Butcher tableau <span>$(A, \mathbf{b})$</span> in direction <span>$(\mathrm{d}A, \mathrm{d}\mathbf{b})$</span> over a list of rooted trees <span>$T$</span> encoded by an <code>AbstractRKOCEvaluator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>adj</code>: <code>AbstractRKOCAdjoint</code> object obtained by applying the adjoint   operator <code>&#39;</code> to an <code>AbstractRKOCEvaluator</code>. In other words, this function   should be called as <code>ev&#39;([dresiduals,] A, dA, b, db)</code> where <code>ev</code> is an   <code>AbstractRKOCEvaluator</code>.</li><li><code>dresiduals</code>: length <span>$|T|$</span> output vector. Each directional derivative   <span>$\nabla_{\mathrm{d}A, \mathrm{d}\mathbf{b}} [   \mathbf{b} \cdot \Phi_t(A) ]$</span> is written to <code>dresiduals[i]</code> in the   order specified when constructing <code>ev</code>. If not provided, a new vector is   allocated and returned.</li><li><code>A</code>: <span>$s \times s$</span> input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).</li><li><code>dA</code>: <span>$s \times s$</span> input matrix containing the direction in which to   differentiate <span>$A$</span>.</li><li><code>b</code>: length <span>$s$</span> input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).</li><li><code>db</code>: length <span>$s$</span> input vector containing the direction in which to   differentiate <span>$\mathbf{b}$</span>.</li></ul><p>Here, <span>$|T|$</span> denotes the number of rooted trees encoded by <code>ev</code>, and <span>$s$</span> denotes the number of stages specified when constructing <code>ev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/AbstractRKInterface.jl#L106-L143">source</a></section><section><div><pre><code class="language-julia hljs">(adj::AbstractRKOCAdjoint{T})(
    [dresiduals::AbstractVector{T},]
    A::AbstractMatrix{T},
    i::Integer,
    j::Integer,
    b::AbstractVector{T},
) -&gt; AbstractVector{T}</code></pre><p>Compute partial derivatives of the Runge–Kutta order conditions <span>$\{ \partial_{A_{i,j}} [ \mathbf{b} \cdot \Phi_t(A) ] : t \in T \}$</span> with respect to <span>$A_{i,j}$</span> at a given Butcher tableau <span>$(A, \mathbf{b})$</span> over a list of rooted trees <span>$T$</span> encoded by an <code>AbstractRKOCEvaluator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>adj</code>: <code>AbstractRKOCAdjoint</code> object obtained by applying the adjoint   operator <code>&#39;</code> to an <code>AbstractRKOCEvaluator</code>. In other words, this function   should be called as <code>ev&#39;([dresiduals,] A, dA, b, db)</code> where <code>ev</code> is an   <code>AbstractRKOCEvaluator</code>.</li><li><code>dresiduals</code>: length <span>$|T|$</span> output vector. Each partial derivative   <span>$\partial_{A_{i,j}} [ \mathbf{b} \cdot \Phi_t(A) ]$</span> is written to   <code>dresiduals[i]</code> in the order specified when constructing <code>ev</code>.   If not provided, a new vector is allocated and returned.</li><li><code>A</code>: <span>$s \times s$</span> input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).</li><li><code>i</code>: row index of the entry of <span>$A$</span> to differentiate with respect to.</li><li><code>j</code>: column index of the entry of <span>$A$</span> to differentiate with respect to.</li><li><code>b</code>: length <span>$s$</span> input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).</li></ul><p>Here, <span>$|T|$</span> denotes the number of rooted trees encoded by <code>ev</code>, and <span>$s$</span> denotes the number of stages specified when constructing <code>ev</code>.</p><p>This method uses an optimized algorithm that should be faster than <code>ev&#39;(dresiduals, A, dA, b, db)</code> when differentiating with respect to a single entry of <span>$A$</span>. It may produce slightly different results due to the non-associative nature of floating-point arithmetic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/AbstractRKInterface.jl#L184-L221">source</a></section><section><div><pre><code class="language-julia hljs">(adj::AbstractRKOCAdjoint{T})(
    [dresiduals::AbstractVector{T},]
    A::AbstractMatrix{T},
    i::Integer,
) -&gt; AbstractVector{T}</code></pre><p>Compute partial derivatives of the Runge–Kutta order conditions <span>$\{ \partial_{b_i} [ \mathbf{b} \cdot \Phi_t(A) ] : t \in T \}$</span> with respect to <span>$b_i$</span> at a given Butcher tableau <span>$A$</span> over a list of rooted trees <span>$T$</span> encoded by an <code>AbstractRKOCEvaluator</code>. (The result is independent of the value of <span>$\mathbf{b}$</span>.)</p><p><strong>Arguments</strong></p><ul><li><code>adj</code>: <code>AbstractRKOCAdjoint</code> object obtained by applying the adjoint   operator <code>&#39;</code> to an <code>AbstractRKOCEvaluator</code>. In other words, this function   should be called as <code>ev&#39;([dresiduals,] A, dA, b, db)</code> where <code>ev</code> is an   <code>AbstractRKOCEvaluator</code>.</li><li><code>dresiduals</code>: length <span>$|T|$</span> output vector. Each partial derivative   <span>$\partial_{b_i} [ \mathbf{b} \cdot \Phi_t(A) ]$</span> is written to   <code>dresiduals[i]</code> in the order specified when constructing <code>ev</code>.   If not provided, a new vector is allocated and returned.</li><li><code>A</code>: <span>$s \times s$</span> input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).</li><li><code>i</code>: index of the entry of <span>$\mathbf{b}$</span> to differentiate with respect to.</li></ul><p>Here, <span>$|T|$</span> denotes the number of rooted trees encoded by <code>ev</code>, and <span>$s$</span> denotes the number of stages specified when constructing <code>ev</code>.</p><p>This method uses an optimized algorithm that should be faster than <code>ev&#39;(dresiduals, A, dA, b, db)</code> when differentiating with respect to a single entry of <span>$\mathbf{b}$</span>. It may produce slightly different results due to the non-associative nature of floating-point arithmetic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/AbstractRKInterface.jl#L262-L295">source</a></section><section><div><pre><code class="language-julia hljs">(adj::AbstractRKOCAdjoint{T})(
    [dA::AbstractMatrix{T},
     db::AbstractVector{T},]
    cost::AbstractRKCost{T},
    A::AbstractMatrix{T},
    b::AbstractVector{T},
) -&gt; Tuple{AbstractMatrix{T}, AbstractVector{T}}</code></pre><p>Compute the gradient of a specified cost function <span>$f$</span> of the residuals of the Runge–Kutta order conditions <span>$\nabla_{A, \mathbf{b}} f(\{ \mathbf{b} \cdot \Phi_t(A) - 1/\gamma(t) : t \in T \})$</span> at a given Butcher tableau <span>$(A, \mathbf{b})$</span> over a list of rooted trees <span>$T$</span> encoded by an <code>AbstractRKOCEvaluator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>adj</code>: <code>AbstractRKOCAdjoint</code> object obtained by applying the adjoint   operator <code>&#39;</code> to an <code>AbstractRKOCEvaluator</code>. In other words, this function   should be called as <code>ev&#39;([dA, db,] cost, A, b)</code> where <code>ev</code> is an   <code>AbstractRKOCEvaluator</code>.</li><li><code>dA</code>: <span>$s \times s$</span> output matrix containing the gradient of <span>$f$</span> with   respect to <span>$A$</span>. If not provided, a new matrix is allocated and returned.</li><li><code>db</code>: length <span>$s$</span> output vector containing the gradient of <span>$f$</span> with   respect to <span>$\mathbf{b}$</span>. If not provided, a new vector is allocated   and returned.</li><li><code>cost</code>: <code>AbstractRKCost</code> object specifying the cost function <span>$f$</span>.</li><li><code>A</code>: <span>$s \times s$</span> input matrix containing the coefficients of a   Runge–Kutta method (i.e., the upper-right block of a Butcher tableau).</li><li><code>b</code>: length <span>$s$</span> input vector containing the weights of a Runge–Kutta   method (i.e., the lower-right row of a Butcher tableau).</li></ul><p>Here, <span>$s$</span> denotes the number of stages specified when constructing <code>ev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/AbstractRKInterface.jl#L334-L366">source</a></section><section><div><pre><code class="language-julia hljs">(adj::AbstractRKOCAdjoint{T})(
    [jacobian::AbstractMatrix{T},
     A::AbstractMatrix{T},
     b::AbstractVector{T},]
    param::AbstractRKParameterization{T},
    x::AbstractVector{T},
) -&gt; AbstractMatrix{T}</code></pre><p>Compute the Jacobian of the residuals of the Runge–Kutta order conditions <span>$\nabla_{\mathbf{x}} \{ \mathbf{b}(\mathbf{x}) \cdot \Phi_t(A(\mathbf{x})) - 1/\gamma(t) : t \in T \}$</span> with respect to a specified Butcher tableau parameterization <span>$\mathbf{x} \in \mathbb{R}^n \mapsto (A(\mathbf{x}), \mathbf{b}(\mathbf{x}))$</span> over a list of rooted trees <span>$T$</span> encoded by an <code>AbstractRKOCEvaluator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>adj</code>: <code>AbstractRKOCAdjoint</code> object obtained by applying the adjoint   operator <code>&#39;</code> to an <code>AbstractRKOCEvaluator</code>. In other words, this function   should be called as <code>ev&#39;([jacobian, A, b,] param, x)</code> where <code>ev</code> is an   <code>AbstractRKOCEvaluator</code>.</li><li><code>jacobian</code>: <span>$|T| \times n$</span> output matrix. The partial derivative of the   <span>$i$</span>th residual with respect to the <span>$j$</span>th coordinate of <span>$\mathbf{x}$</span>   is written to <code>jacobian[i, j]</code>. If not provided, a new matrix is allocated   and returned.</li><li><code>A</code>: <span>$s \times s$</span> output matrix containing the output   <span>$A(\mathbf{x})$</span> of the Butcher tableau parameterization.   If not provided, a new temporary matrix is allocated.</li><li><code>b</code>: length <span>$s$</span> output vector containing the output   <span>$\mathbf{b}(\mathbf{x})$</span> of the Butcher tableau parameterization.   If not provided, a new temporary vector is allocated.</li><li><code>param</code>: <code>AbstractRKParameterization</code> object specifying a Butcher tableau   parameterization, i.e., a mapping from a vector of parameters   <span>$\mathbf{x} \in \mathbb{R}^n$</span> to a Butcher tableau   <span>$(A(\mathbf{x}), \mathbf{b}(\mathbf{x}))$</span>.</li><li><code>x</code>: length <span>$n$</span> input vector containing the parameters <span>$\mathbf{x}$</span>.</li></ul><p>Here, <span>$|T|$</span> denotes the number of rooted trees encoded by <code>ev</code>, <span>$s$</span> denotes the number of stages specified when constructing <code>ev</code>, and <span>$n$</span> denotes the number of free parameters in <code>param</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/AbstractRKInterface.jl#L407-L447">source</a></section></article><h2 id="Cost-Functions"><a class="docs-heading-anchor" href="#Cost-Functions">Cost Functions</a><a id="Cost-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKCost.RKCostL1" href="#RungeKuttaToolKit.RKCost.RKCostL1"><code>RungeKuttaToolKit.RKCost.RKCostL1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p class="math-container">\[\sum_{t \in T} \left\lvert
\mathbf{b} \cdot \Phi_t(A) - \frac{1}{\gamma(t)}
\right\rvert\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKCost.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKCost.RKCostWeightedL1" href="#RungeKuttaToolKit.RKCost.RKCostWeightedL1"><code>RungeKuttaToolKit.RKCost.RKCostWeightedL1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p class="math-container">\[\sum_{t \in T} w_t \left\lvert
\mathbf{b} \cdot \Phi_t(A) - \frac{1}{\gamma(t)}
\right\rvert\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKCost.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKCost.RKCostL2" href="#RungeKuttaToolKit.RKCost.RKCostL2"><code>RungeKuttaToolKit.RKCost.RKCostL2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p class="math-container">\[\sum_{t \in T} \left(
\mathbf{b} \cdot \Phi_t(A) - \frac{1}{\gamma(t)}
\right)^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKCost.jl#L301-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKCost.RKCostWeightedL2" href="#RungeKuttaToolKit.RKCost.RKCostWeightedL2"><code>RungeKuttaToolKit.RKCost.RKCostWeightedL2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p class="math-container">\[\sum_{t \in T} w_t \left(
\mathbf{b} \cdot \Phi_t(A) - \frac{1}{\gamma(t)}
\right)^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKCost.jl#L408-L414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKCost.RKCostLInfinity" href="#RungeKuttaToolKit.RKCost.RKCostLInfinity"><code>RungeKuttaToolKit.RKCost.RKCostLInfinity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p class="math-container">\[\max_{t \in T} \left\lvert
\mathbf{b} \cdot \Phi_t(A) - \frac{1}{\gamma(t)}
\right\rvert\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKCost.jl#L517-L523">source</a></section></article><p>Derivatives are not yet implemented for <code>RKCostLInfinity</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKCost.RKCostWeightedLInfinity" href="#RungeKuttaToolKit.RKCost.RKCostWeightedLInfinity"><code>RungeKuttaToolKit.RKCost.RKCostWeightedLInfinity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p class="math-container">\[\max_{t \in T} w_t \left\lvert
\mathbf{b} \cdot \Phi_t(A) - \frac{1}{\gamma(t)}
\right\rvert\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKCost.jl#L557-L563">source</a></section></article><p>Derivatives are not yet implemented for <code>RKCostWeightedLInfinity</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKCost.RKCostHuber" href="#RungeKuttaToolKit.RKCost.RKCostHuber"><code>RungeKuttaToolKit.RKCost.RKCostHuber</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p class="math-container">\[\sum_{t \in T} H_\delta\!\left(
\mathbf{b} \cdot \Phi_t(A) - \frac{1}{\gamma(t)}
\right)\]</p><p class="math-container">\[H_\delta(x) = \begin{cases}
x^2 &amp; \text{if } \lvert x \rvert \leq \delta \\
2 \delta \lvert x \rvert - \delta^2 &amp; \text{otherwise}
\end{cases}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKCost.jl#L597-L609">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKCost.RKCostWeightedHuber" href="#RungeKuttaToolKit.RKCost.RKCostWeightedHuber"><code>RungeKuttaToolKit.RKCost.RKCostWeightedHuber</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p class="math-container">\[\sum_{t \in T} w_t H_\delta\!\left(
\mathbf{b} \cdot \Phi_t(A) - \frac{1}{\gamma(t)}
\right)\]</p><p class="math-container">\[H_\delta(x) = \begin{cases}
x^2 &amp; \text{if } \lvert x \rvert \leq \delta \\
2 \delta \lvert x \rvert - \delta^2 &amp; \text{otherwise}
\end{cases}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKCost.jl#L730-L742">source</a></section></article><h2 id="Parameterizations"><a class="docs-heading-anchor" href="#Parameterizations">Parameterizations</a><a id="Parameterizations-1"></a><a class="docs-heading-anchor-permalink" href="#Parameterizations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKParameterization.RKParameterizationExplicit" href="#RungeKuttaToolKit.RKParameterization.RKParameterizationExplicit"><code>RungeKuttaToolKit.RKParameterization.RKParameterizationExplicit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKParameterization.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKParameterization.RKParameterizationDiagonallyImplicit" href="#RungeKuttaToolKit.RKParameterization.RKParameterizationDiagonallyImplicit"><code>RungeKuttaToolKit.RKParameterization.RKParameterizationDiagonallyImplicit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKParameterization.jl#L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKParameterization.RKParameterizationImplicit" href="#RungeKuttaToolKit.RKParameterization.RKParameterizationImplicit"><code>RungeKuttaToolKit.RKParameterization.RKParameterizationImplicit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKParameterization.jl#L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RungeKuttaToolKit.RKParameterization.RKParameterizationParallelExplicit" href="#RungeKuttaToolKit.RKParameterization.RKParameterizationParallelExplicit"><code>RungeKuttaToolKit.RKParameterization.RKParameterizationParallelExplicit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dzhang314/RungeKuttaToolKit.jl/blob/2c8aba0dbc18aefe72a6be4f8f725771ded6cc59/src/RKParameterization.jl#L659">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="background/">Background »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 11 September 2024 12:13">Wednesday 11 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
